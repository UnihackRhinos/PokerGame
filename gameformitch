import random
import time




# def int_input(prompt="", restricted_to=None):
#     while True:
#         player_input = input(prompt)
#         try:
#             int_player_input = int(player_input)
#         except ValueError:
#             continue
#         if restricted_to is None:
#             break
#         elif int_player_input in restricted_to:
#             break
#     return int_player_input


class Game:
    


    class Deck:
        class Card:
            def __init__(self, suit, value):
                self.suit = suit
                self.value = value

            def show(self):
                return (f"{self.value} of {self.suit}")
        
        suits = ["Clubs", "Spades", "Hearts", "Diamonds"]
        values = ["Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King", "Ace"]

        def __init__(self):
            self.cards = []
            self.build()

        def build(self):
            for i in self.suits:
                for j in self.values:
                    self.cards.append(self.Card(i, j).show())


        # CODY COde


    def __init__(self):
        self.allin = [0,0]
        self.ready = False
        self.deck = self.Deck().cards
        self.runout = []
        self.hand = [[], []]
        self.stack = [200, 200]
        self.num_of_actions = [0, 0]
        self.position = [0, 1] # who is in position???
        self.pot = 0
        self.hand_over = False
        self.committed = 0
        self.owed = [0, 0]
        self.betting_round = 0
        player_has_folded = False
        
    bigblind = 20
    smallblind = 10


    def connected(self): #determine if client has connected
        return self.ready

    def deal(self):
        for i in range(2):
            the_int = random.randint(0, len(self.deck) - 1)
            rand_card = self.deck[the_int]
            self.hand[0].append(rand_card)
            self.deck.pop(the_int)
        for i in range(2):
            the_int = random.randint(0, len(self.deck) - 1)
            rand_card = self.deck[the_int]
            self.hand[1].append(rand_card)
            self.deck.pop(the_int)

    # def flop(self):
    #     for i in range(3):
    #         the_int = random.randint(0, len(self.deck) - 1)
    #         rand_card = self.deck[the_int]
    #         self.runout.append(rand_card)
    #         self.deck.pop(the_int)

    # def turn(self):
    #     the_int = random.randint(0, len(self.deck) - 1)
    #     rand_card = self.deck[the_int]
    #     self.runout.append(rand_card)
    #     self.deck.pop(the_int)

    # def river(self):
    #     the_int = random.randint(0, len(self.deck) - 1)
    #     rand_card = self.deck[the_int]
    #     self.runout.append(rand_card)
    #     self.deck.pop(the_int)

    def blinds(self,player):
        if self.position[player] == 0:  # not dealer and bigblind
            self.pot += self.bigblind
            self.stack[player] -= self.bigblind
            self.committed += self.bigblind
        elif self.position[player] == 1:  # is dealer and smallblind
            self.pot += self.smallblind
            self.stack[player] -= self.smallblind
            self.committed += self.smallblind
            self.owed[player] = 10

    def betting(self, player, choice, raise_amount = bigblind):
        if self.owed[player]:  # finds out if player is able to call
            if choice == 1:     #if player chooses to call
                self.committed += self.owed[player]
                self.stack[player] -= self.owed[player]
                self.pot += self.owed[player]
                self.owed[player] = 0
                self.num_of_actions[player] += 1
            elif choice == 2:   #if player chooses to raise
                self.committed += raise_amount + self.owed[player]
                self.stack[player] -= (raise_amount + self.owed[player])
                self.pot += raise_amount + self.owed[player]
                self.owed[player] = 0
                self.owed[(player + 1) % 2] = raise_amount
                self.num_of_actions[player] += 1
            elif choice == 3:   #if player chooses to fold
                self.hand_over = True
                player_has_folded = True

        elif self.owed[player] == 0 and self.num_of_actions[player] >= 1:  # finds out if player is able to check
            if choice == 1:
                self.num_of_actions[player] += 1

            elif choice == 2:  # if player chooses to raise
                self.committed += raise_amount + self.owed[player]
                self.stack[player] -= (raise_amount + self.owed[player])
                self.pot += raise_amount + self.owed[player]
                self.owed[player] = 0
                self.owed[(player + 1) % 2] = raise_amount
                self.num_of_actions[player] += 1
            elif choice == 3:  # if player chooses to fold
                self.hand_over = True
                player_has_folded = True

        else:
            self.betting_round += 1


    # def play_game(self):
    #     while not self.hand_over:
    #         self.blinds()
    #         self.deal()
    #         self.betting()
    #         self.flop()
    #         self.betting()
    #         self.turn()
    #         self.betting()
    #         self.river()
    #         self.betting()

# game1 = Game(1).play_game
# game1()
